# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XvPIShSvgTRGGWZZDop2HBZKYkHHV9mo
"""

import numpy as np

# ---------------------------
# Economic Load Dispatch Setup
# ---------------------------

# Generator cost coefficients (a, b, c)
# Example: 3 generators
a = np.array([0.0015, 0.0010, 0.0012])
b = np.array([7.0, 8.0, 6.5])
c = np.array([100, 120, 150])

# Power limits (MW)
Pmin = np.array([100, 50, 80])
Pmax = np.array([500, 200, 300])

# Total power demand
PD = 700

# ---------------------------
# Grey Wolf Optimization Setup
# ---------------------------

num_wolves = 30      # Population size
max_iter = 100       # Number of iterations
dim = len(a)         # Number of generators

# Initialize positions (each wolf = generator power vector)
positions = np.random.uniform(Pmin, Pmax, (num_wolves, dim))

# Fitness function (total fuel cost + penalty if power â‰  PD)
def fitness(P):
    total_cost = np.sum(a * P**2 + b * P + c)
    penalty = 1000 * abs(np.sum(P) - PD)  # power balance constraint
    return total_cost + penalty

# Initialize alpha, beta, delta (best 3 wolves)
alpha, beta, delta = np.zeros(dim), np.zeros(dim), np.zeros(dim)
alpha_score, beta_score, delta_score = float('inf'), float('inf'), float('inf')

# Evaluate initial fitness
for i in range(num_wolves):
    f = fitness(positions[i])
    if f < alpha_score:
        delta, delta_score = beta, beta_score
        beta, beta_score = alpha, alpha_score
        alpha, alpha_score = positions[i].copy(), f
    elif f < beta_score:
        delta, delta_score = beta, beta_score
        beta, beta_score = positions[i].copy(), f
    elif f < delta_score:
        delta, delta_score = positions[i].copy(), f

# ---------------------------
# Main GWO Loop
# ---------------------------
for t in range(max_iter):
    a_coeff = 2 - 2 * (t / max_iter)  # linearly decreases from 2 to 0

    for i in range(num_wolves):
        for j in range(dim):
            r1, r2 = np.random.rand(), np.random.rand()
            A1, C1 = 2 * a_coeff * r1 - a_coeff, 2 * r2
            D_alpha = abs(C1 * alpha[j] - positions[i, j])
            X1 = alpha[j] - A1 * D_alpha

            r1, r2 = np.random.rand(), np.random.rand()
            A2, C2 = 2 * a_coeff * r1 - a_coeff, 2 * r2
            D_beta = abs(C2 * beta[j] - positions[i, j])
            X2 = beta[j] - A2 * D_beta

            r1, r2 = np.random.rand(), np.random.rand()
            A3, C3 = 2 * a_coeff * r1 - a_coeff, 2 * r2
            D_delta = abs(C3 * delta[j] - positions[i, j])
            X3 = delta[j] - A3 * D_delta

            # Update position
            positions[i, j] = (X1 + X2 + X3) / 3

        # Apply generator limits
        positions[i] = np.clip(positions[i], Pmin, Pmax)

        # Evaluate fitness
        f = fitness(positions[i])
        if f < alpha_score:
            delta, delta_score = beta, beta_score
            beta, beta_score = alpha, alpha_score
            alpha, alpha_score = positions[i].copy(), f
        elif f < beta_score:
            delta, delta_score = beta, beta_score
            beta, beta_score = positions[i].copy(), f
        elif f < delta_score:
            delta, delta_score = positions[i].copy(), f

    if t % 10 == 0:
        print(f"Iteration {t:03d} | Best Cost: {alpha_score:.4f}")

# ---------------------------
# Results
# ---------------------------
print("\n=== Optimal Dispatch ===")
for i in range(dim):
    print(f"Generator {i+1}: {alpha[i]:.2f} MW")
print(f"Total Power: {np.sum(alpha):.2f} MW")
print(f"Total Cost:  ${alpha_score:.2f}")